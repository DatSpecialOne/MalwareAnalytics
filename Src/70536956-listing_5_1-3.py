#!/usr/bin/python

import argparse
import os
import networkx
from networkx.drawing.nx_pydot import write_dot
import itertools
import pprint
import pefile
from capstone import *

"""
Copyright (c) 2015, Joshua Saxe
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name 'Joshua Saxe' nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JOSHUA SAXE BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# prerequisites = pefile and capstone. Install vai commands:
# pip install pefile
# pip install capstone


def sorensen(jaccard):
    """
    Wikipedia states that you can caculate sorensen dice coeficient from a jaccard value and
    vice versa:J=S/(2-S) and S=2J/(1+J)
    """
    return 2*jaccard/(1+jaccard)

def jaccard(set1,set2):
    """
    Compute the Jaccard distance between two sets by taking
    their intersection, union and then dividing the number
    of elements in the intersection by the number of elements
    in their union.
    """
    intersection = set1.intersection(set2)
    intersection_length = float(len(intersection))
    union = set1.union(set2)
    union_length = float(len(union))
    return intersection_length / union_length

def getSequence(fullpath, nGram):
    pe = pefile.PE(fullpath)
    limit = 5000
    #codeSectionStart = pe.sections[0].PointerToRawData #s
    entryPoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    entryPointAddress = entryPoint + pe.OPTIONAL_HEADER.ImageBase
    sizeOfData = pe.sections[0].SizeOfRawData#pe.section[0] is index to code/text section. return size so i can work out is less than 5000

    if sizeOfData < limit:
        limit = sizeOfData

    binary = pe.get_memory_mapped_image()[entryPoint:entryPoint + limit]
      
    #now create dissasembler depending mode on bit. not sure if it was needed but nice extra
    dis = Cs(CS_ARCH_X86, CS_MODE_64)
    if hex(pe.FILE_HEADER.Machine) == "0x14c": #32bit
        dis = Cs(CS_ARCH_X86, CS_MODE_32)

    sequenceStore = "" #list variable to store the instructions in text section

    for i in dis.disasm(binary, entryPointAddress):# loop going through the instructions and storing in sequence store
        sequenceStore += "%s\t%s\n" %(i.mnemonic, i.op_str)
    
    sequenceStore = sequenceStore.split("\n")   

    grams = zip(*[sequenceStore[i:] for i in range(nGram)]) #generates N grams with window size = ngrams

    return set(grams)#returns n grams as a set for jaccard(set1,set2)

def getIAT(fullpath):
    iat = set()
    pe = pefile.PE(fullpath) #opening pe file and 
    for importEntry in pe.DIRECTORY_ENTRY_IMPORT:
        iat.add(importEntry.dll)#.dll returns import entrys relative dll name
    if len(iat) == 0: #if there are no DLLs found perform string based similarity instead
        iat = getstrings(fullpath)
    return iat

def getstrings(fullpath):
    """
    Extract strings from the binary indicated by the 'fullpath'
    parameter, and then return the set of unique strings in
    the binary.
    """
    strings = os.popen("strings '{0}'".format(fullpath)).read()
    strings = set(strings.split("\n"))
    return strings

def pecheck(fullpath):
    """
    Do a cursory sanity check to make sure 'fullpath' is
    a Windows PE executable (PE executables start with the
    two bytes 'MZ')
    """
    return open(fullpath).read(2) == "MZ"

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Identify similarities between malware samples and build similarity graph"
    )

    parser.add_argument(
        "target_directory",
        help="Directory containing malware"
    )

    parser.add_argument(
        "output_dot_file",
        help="Where to save the output graph DOT file"
    )

    parser.add_argument(
        "--similarity_base", "-s", dest = "similarity_base", type = str, default = "string", help = "Type of similarity analysis. Options: string, iat, sequence")

    parser.add_argument("--N_gram", "-n", dest = "nGram", type = int, default = 3, help = "N gram value to be used in sequence similarity. Options include: 3, 7, 11")

    parser.add_argument(
        "--jaccard_index_threshold","-j",dest="threshold",type=float,
        default=0.8,help="Threshold above which to create an 'edge' between samples"
    )

    parser.add_argument(
        "--sorensen_dice_threshhold", "-d", dest = "sorensen_dice_threshold", type = float, default = 0, help = "If you wish to apply sorensen dice coefficient please enter a threshold between 0-1, for which two samples will be connected via an edge.")

    args = parser.parse_args()
    malware_paths = [] # where we'll store the malware file paths
    malware_attributes = dict() # where we'll store the malware strings
    graph = networkx.Graph() # the similarity graph

    for root, dirs, paths in os.walk(args.target_directory):
        # walk the target directory tree and store all of the file paths
        for path in paths:
            full_path = os.path.join(root,path)
            malware_paths.append(full_path)

    # filter out any paths that aren't PE files
    malware_paths = filter(pecheck, malware_paths)

    #if sequence based similarity
    if args.similarity_base == "sequence":
        nGramValues = {3,7,11}# to ensure user only enters valid Ngram values
        if args.nGram in nGramValues:
            for path in malware_paths:
                attributes = getSequence(path,args.nGram)
                # print attributes and exit() were there for testing reasons
                #print attributes
                #exit()
                print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
                malware_attributes[path] = attributes

                # add each malware file to the graph
                graph.add_node(path,label=os.path.split(path)[-1][:10])
        else:
            print("Ngram: Invalid Value. Options: 3, 7, 11")
            exit()

    #if IAT based similarity
    if args.similarity_base == "iat":
    # get and store the DLLs for all of the malware PE files
        for path in malware_paths:
            attributes = getIAT(path)#returns dll set
            #print attributes and exit() were there for testing reasons
            #print attributes
            #exit()
            print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
            malware_attributes[path] = attributes

            # add each malware file to the graph
            graph.add_node(path,label=os.path.split(path)[-1][:10])

    #if string based similarity
    if args.similarity_base == "string":
    # get and store the strings for all of the malware PE files
        for path in malware_paths:
            attributes = getstrings(path)
            print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
            malware_attributes[path] = attributes

            # add each malware file to the graph
            graph.add_node(path,label=os.path.split(path)[-1][:10])

    if args.sorensen_dice_threshold > 0:
        for malware1,malware2 in itertools.combinations(malware_paths,2):
            # compute the jaccard distance for the current pair
            jaccard_index = jaccard(malware_attributes[malware1],malware_attributes[malware2])
            #compute Sorensen dice coefficient
            sorensen_dice_index = sorensen(jaccard_index)
            #print and exit for testing purposes
            #print sorensen_dice_index
            #exit()
            # if the sorensen dice coeficient above the threshold add an edge
            if sorensen_dice_index > args.sorensen_dice_threshold:
                print malware1, malware2, sorensen_dice_index
                graph.add_edge(malware1,malware2,penwidth=1+(sorensen_dice_index-args.sorensen_dice_threshold)*10)

    else:
        # iterate through all pairs of malware
        for malware1,malware2 in itertools.combinations(malware_paths,2):

            # compute the jaccard distance for the current pair
            jaccard_index = jaccard(malware_attributes[malware1],malware_attributes[malware2])

            # if the jaccard distance is above the threshold add an edge
            if jaccard_index > args.threshold:
                print malware1,malware2,jaccard_index
                graph.add_edge(malware1,malware2,penwidth=1+(jaccard_index-args.threshold)*10)

    # write the graph to disk so we can visualize it
    write_dot(graph,args.output_dot_file)
