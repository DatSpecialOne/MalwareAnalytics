#!/usr/bin/python

import argparse
import os
import networkx
from networkx.drawing.nx_pydot import write_dot
import itertools
import pprint
import pefile
from capstone import *
import pandas as pd
#%matplotlib inline # magic command for sns to use matplotlib: https://stackoverflow.com/questions/34928370/setting-properly-aligned-axis-labels-on-matplotlib-pcolor-plot
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

"""
Copyright (c) 2015, Joshua Saxe
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name 'Joshua Saxe' nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JOSHUA SAXE BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# prerequisites = pefile and capstone. Install vai commands:
# pip install pefile
# pip install capstone
# pip install pandas
# pip install matplotlib
# pip install numpy 
#pip install seaborn

def sorensen(jaccard):
    """
    Wikipedia states that you can caculate sorensen dice coeficient from a jaccard value and
    vice versa:J=S/(2-S) and S=2J/(1+J)
    """
    return 2*jaccard/(1+jaccard)

def jaccard(set1,set2):
    """
    Compute the Jaccard distance between two sets by taking
    their intersection, union and then dividing the number
    of elements in the intersection by the number of elements
    in their union.
    """
    intersection = set1.intersection(set2)
    intersection_length = float(len(intersection))
    union = set1.union(set2)
    union_length = float(len(union))
    return intersection_length / union_length

def getSequence(fullpath, nGram):
    pe = pefile.PE(fullpath)
    limit = 5000
    #codeSectionStart = pe.sections[0].PointerToRawData #s
    entryPoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    entryPointAddress = entryPoint + pe.OPTIONAL_HEADER.ImageBase
    sizeOfData = pe.sections[0].SizeOfRawData#pe.section[0] is index to code/text section. return size so i can work out is less than 5000

    if sizeOfData < limit:
        limit = sizeOfData

    binary = pe.get_memory_mapped_image()[entryPoint:entryPoint + limit]
      
    #now create dissasembler depending mode on bit. not sure if it was needed but nice extra
    dis = Cs(CS_ARCH_X86, CS_MODE_64)
    if hex(pe.FILE_HEADER.Machine) == "0x14c": #32bit
        dis = Cs(CS_ARCH_X86, CS_MODE_32)

    sequenceStore = "" #list variable to store the instructions in text section

    for i in dis.disasm(binary, entryPointAddress):# loop going through the instructions and storing in sequence store
        sequenceStore += "%s\t%s\n" %(i.mnemonic, i.op_str)
    
    sequenceStore = sequenceStore.split("\n")   

    grams = zip(*[sequenceStore[i:] for i in range(nGram)]) #generates N grams with window size = ngrams

    return set(grams)#returns n grams as a set for jaccard(set1,set2)

def getIAT(fullpath):
    iat = set()
    pe = pefile.PE(fullpath) #opening pe file and 
    for importEntry in pe.DIRECTORY_ENTRY_IMPORT:
        iat.add(importEntry.dll)#.dll returns import entrys relative dll name
    if len(iat) == 0: #if there are no DLLs found perform string based similarity instead
        iat = getstrings(fullpath)
    return iat

def getstrings(fullpath):
    """
    Extract strings from the binary indicated by the 'fullpath'
    parameter, and then return the set of unique strings in
    the binary.
    """
    strings = os.popen("strings '{0}'".format(fullpath)).read()
    strings = set(strings.split("\n"))
    return strings

def pecheck(fullpath):
    """
    Do a cursory sanity check to make sure 'fullpath' is
    a Windows PE executable (PE executables start with the
    two bytes 'MZ')
    """
    return open(fullpath).read(2) == "MZ"

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Identify similarities between malware samples and build similarity graph"
    )

    parser.add_argument(
        "target_directory",
        help="Directory containing malware"
    )

    parser.add_argument(
        "output_dot_file",
        help="Where to save the output graph DOT file"
    )

    parser.add_argument(
        "--similarity_base", "-s", dest = "similarity_base", type = str, default = "string", help = "Type of similarity analysis. Options: string, iat, sequence")

    parser.add_argument("--N_gram", "-n", dest = "nGram", type = int, default = 3, help = "N gram value to be used in sequence similarity. Options include: 3, 7, 11")

    parser.add_argument(
        "--jaccard_index_threshold","-j",dest="threshold",type=float,
        default=0.7,help="Threshold above which to create an 'edge' between samples"
    )

    parser.add_argument(
        "--sorensen_dice_threshhold", "-d", dest = "sorensen_dice_threshold", type = float, default = 0, help = "If you wish to apply sorensen dice coefficient please enter a threshold between 0-1, for which two samples will be connected via an edge.")

    parser.add_argument("--matrix","-m", dest = "matrixBool", type = bool, default = True, help = "Display similarity matrix.")

    args = parser.parse_args()
    malware_paths = [] # where we'll store the malware file paths
    malware_attributes = dict() # where we'll store the malware strings
    graph = networkx.Graph() # the similarity graph

    for root, dirs, paths in os.walk(args.target_directory):
        # walk the target directory tree and store all of the file paths
        for path in paths:
            full_path = os.path.join(root,path)
            malware_paths.append(full_path)

    # filter out any paths that aren't PE files
    malware_paths = filter(pecheck, malware_paths)

    #if sequence based similarity
    if args.similarity_base == "sequence":
        nGramValues = {3,7,11}# to ensure user only enters valid Ngram values
        if args.nGram in nGramValues:
            for path in malware_paths:
                attributes = getSequence(path,args.nGram)
                # print attributes and exit() were there for testing reasons
                #print attributes
                #exit()
                print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
                malware_attributes[path] = attributes

                # add each malware file to the graph
                graph.add_node(path,label=os.path.split(path)[-1][:10])
        else:
            print("Ngram: Invalid Value. Options: 3, 7, 11")
            exit()

    #if IAT based similarity
    if args.similarity_base == "iat":
    # get and store the DLLs for all of the malware PE files
        for path in malware_paths:
            attributes = getIAT(path)#returns dll set
            #print attributes and exit() were there for testing reasons
            #print attributes
            #exit()
            print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
            malware_attributes[path] = attributes

            # add each malware file to the graph
            graph.add_node(path,label=os.path.split(path)[-1][:10])

    #if string based similarity
    if args.similarity_base == "string":
    # get and store the strings for all of the malware PE files
        for path in malware_paths:
            attributes = getstrings(path)
            print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
            malware_attributes[path] = attributes

            # add each malware file to the graph
            graph.add_node(path,label=os.path.split(path)[-1][:10])

    if args.sorensen_dice_threshold > 0:
        for malware1,malware2 in itertools.combinations(malware_paths,2):
            # compute the jaccard distance for the current pair
            jaccard_index = jaccard(malware_attributes[malware1],malware_attributes[malware2])
            #compute Sorensen dice coefficient
            sorensen_dice_index = sorensen(jaccard_index)
            #print and exit for testing purposes
            #print sorensen_dice_index
            #exit()
            # if the sorensen dice coeficient above the threshold add an edge
            if sorensen_dice_index > args.sorensen_dice_threshold:
                print malware1, malware2, sorensen_dice_index
                graph.add_edge(malware1,malware2,penwidth=1+(sorensen_dice_index-args.sorensen_dice_threshold)*10)

    else:
        # iterate through all pairs of malware
        for malware1,malware2 in itertools.combinations(malware_paths,2):

            # compute the jaccard distance for the current pair
            jaccard_index = jaccard(malware_attributes[malware1],malware_attributes[malware2])

            # if the jaccard distance is above the threshold add an edge
            if jaccard_index > args.threshold:
                print malware1,malware2,jaccard_index
                graph.add_edge(malware1,malware2,penwidth=1+(jaccard_index-args.threshold)*10)
    
    #if user selected matrix
    if args.matrixBool == True:
        print ("calculating matrix, please wait...")
        #outlining matrix 
        columnRow = []#for csv data frame
        for path in malware_paths:#populate columns with name of malware
            columnRow.append(os.path.basename(path)) 
        #creating zero matrix 
        malwareMatrixAllVal = [[0]*len(columnRow) for i in range(len(columnRow))]
        #nested for loop for indexing malawre and populating it with the corosponding similarity val
        for malware1 in range (len(malware_paths)):
            for malware2 in range(len(malware_paths)):
                index = jaccard(malware_attributes[malware_paths[malware1]],malware_attributes[malware_paths[malware2]])
                if args.sorensen_dice_threshold > 0:
                    index = sorensen(index)
                malwareMatrixAllVal[malware1][malware2] = index
         #creating data frame to store matrix as a table so can be easily viewed via csv
        dfAllVal = pd.DataFrame(malwareMatrixAllVal,index = columnRow ,columns = columnRow)
        
        """ #This produces a heat map with the values inside the heat map however this shows
        up for a split seccond on my screen then the whole vm crashes! Because of this I have
        created one with out lables. If you wish to see the values please read the CSV file.
        #creating graph: inspired by https://matplotlib.org/3.1.1/gallery /images_contours_and_fields/image_annotated_heatmap.html
        
        fig, ax = plt.subplots()
        im = ax.imshow(malwareMatrixAllVal, cmap=plt.cm.Blues)

        ax.set_title("Similarity Analysis Matrix")

        

        ax.set_yticks(np.arange(len(columnRow))-.5)
        ax.set_yticklabels(columnRow)

        ax.set_xticks(np.arange(len(columnRow))-.5)
        ax.set_xticklabels(columnRow)

        ax.tick_params(top=True, bottom=False,labeltop=True, labelbottom=False)

        #rotating lables on graph
        plt.setp(ax.get_xticklabels(), rotation=45, ha="right", rotation_mode="anchor")
        
        for i in range(len(columnRow)):
            for j in range(len(columnRow)):
                text = ax.text(i,j , malwareMatrixAllVal[j][i], fontsize = 10, ha = "center", va = "center", color = "b")
        fig.tight_layout()
        
        fig.savefig('70536956-malwareMatrixAllVal.png')
        #plt.show()
        """

        """ 1 st attempt
        graph = plt.pcolor(dfAllVal, cmap = plt.cm.Reds)
        #graph.title("similarity matrix")
        graph.xlabel("malware")
        graph.ylabel("malware")

        plt.show(graph)
        """
        #print (len (columnRow))#used to find number of malwre sample so lables fit
        plt.figure(figsize = (100,100))# seting figure to appropiet size so lables fit
        heatmap = sns.heatmap(dfAllVal,cmap=plt.cm.RdYlGn,vmin=0,vmax=1,cbar=True)# creating heatmap from dataframe
        heatmap.axes.xaxis.set_ticks_position("top")#putting x axis at top so that it aproprietly allignes wit the matrix!
        heatmap.set_xticklabels(heatmap.get_xticklabels(),rotation=45, ha="left")#adjusting labels
        print ("Saving heatmap to: 70536956-malwareMatrixAllVal.png")
        plt.savefig("70536956-malwareMatrixAllVal.png")#saving matrix
        #exporting to csv so can be viewed exsternally!
        print("Saving malwareMatrixAllVal dataframe to:70536956-malwareMatrixAllVal.csv")
        dfAllVal.to_csv('malwareMatrixAllVal.csv')
    # write the graph to disk so we can visualize it
    write_dot(graph,args.output_dot_file)
