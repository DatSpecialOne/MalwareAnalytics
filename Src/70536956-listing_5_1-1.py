#!/usr/bin/python

import argparse
import os
import networkx
from networkx.drawing.nx_pydot import write_dot
import itertools
import pprint
import pefile

"""
Copyright (c) 2015, Joshua Saxe
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name 'Joshua Saxe' nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JOSHUA SAXE BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# prerequisites = pefile. Install vai commands:
# pip install pefile

def jaccard(set1,set2):
    """
    Compute the Jaccard distance between two sets by taking
    their intersection, union and then dividing the number
    of elements in the intersection by the number of elements
    in their union.
    """
    intersection = set1.intersection(set2)
    intersection_length = float(len(intersection))
    union = set1.union(set2)
    union_length = float(len(union))
    return intersection_length / union_length


"""
Contacted DANIELE and he said the approach i took originally was wrong so id loose marks even though i retreived the same results with the new approach using pefile. 

# getIAT func used to create a set of dll used in the malware. 
def getIAT(fullpath):
    iat = os.popen("objdump -x '{0}'".format(fullpath)).read() #use objdump to find dll in IAT
    iat = iat.split("\n")
    iat = filter(lengthLess,iat)#filters out lines too small to be dll if there are some
    iat = set(filter(dll,iat))# had to use set last as flter outputs a list, this filters for dlls
    iat = {i.replace("\tDLL Name: ","") for i in iat}# to remove jargon
    if len(iat) == 0: #if there are no DLLs found perform string based similarity instead
        iat =  getstrings(fullpath)
    return iat

# lengthLess func is to filter so that strings less that 5 are not in the iat list
# this is so the pointer to a character in the dll func doesnt go out of the strings bounds.
# Therefore avoids having to iterate over strings which are too short to have the ".dll" exstention
def lengthLess(string):
    return len(string) >= 5

# dll func is used to filter so that only strings with the ".dll" exstention are present in list. result are strings that are dynamic libraries 
def dll(string):
    length = len(string)
    lastFourChars = string[-4] + string[-3] + string[-2] + string[-1]
    return lastFourChars == ".dll"
"""

def getIAT(fullpath):
    iat = set()
    pe = pefile.PE(fullpath) #opening pe file 
    for importEntry in pe.DIRECTORY_ENTRY_IMPORT:#loop through entrys in the import directory
        iat.add(importEntry.dll)#.dll returns import entrys relative dll name
    if len(iat) == 0: #if there are no DLLs found perform string based similarity instead
        iat = getstrings(fullpath)
    return iat

def getstrings(fullpath):
    """
    Extract strings from the binary indicated by the 'fullpath'
    parameter, and then return the set of unique strings in
    the binary.
    """
    strings = os.popen("strings '{0}'".format(fullpath)).read()
    strings = set(strings.split("\n"))
    return strings

def pecheck(fullpath):
    """
    Do a cursory sanity check to make sure 'fullpath' is
    a Windows PE executable (PE executables start with the
    two bytes 'MZ')
    """
    return open(fullpath).read(2) == "MZ"

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Identify similarities between malware samples and build similarity graph"
    )

    parser.add_argument(
        "target_directory",
        help="Directory containing malware"
    )

    parser.add_argument(
        "output_dot_file",
        help="Where to save the output graph DOT file"
    )

    parser.add_argument(
        "--similarity_base", "-s", dest = "similarity_base", type = str, default = "iat", help = "Type of similarity analysis. Options: string, iat")

    parser.add_argument(
        "--jaccard_index_threshold","-j",dest="threshold",type=float,
        default=0.8,help="Threshold above which to create an 'edge' between samples"
    )

    args = parser.parse_args()
    malware_paths = [] # where we'll store the malware file paths
    malware_attributes = dict() # where we'll store the malware strings
    graph = networkx.Graph() # the similarity graph

    for root, dirs, paths in os.walk(args.target_directory):
        # walk the target directory tree and store all of the file paths
        for path in paths:
            full_path = os.path.join(root,path)
            malware_paths.append(full_path)

    # filter out any paths that aren't PE files
    malware_paths = filter(pecheck, malware_paths)

    #if IAT based similarity
    if args.similarity_base == "iat":
    # get and store the DLLs for all of the malware PE files
        for path in malware_paths:
            attributes = getIAT(path)#returns dll set
            #print attributes and exit() were there for testing reasons
            #print attributes
            #exit()
            print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
            malware_attributes[path] = attributes

            # add each malware file to the graph
            graph.add_node(path,label=os.path.split(path)[-1][:10])

    #if string based similarity
    if args.similarity_base == "string":
    # get and store the strings for all of the malware PE files
        for path in malware_paths:
            attributes = getstrings(path)
            print "Extracted {0} attributes from {1} ...".format(len(attributes),path)
            malware_attributes[path] = attributes

            # add each malware file to the graph
            graph.add_node(path,label=os.path.split(path)[-1][:10])

    # iterate through all pairs of malware
    for malware1,malware2 in itertools.combinations(malware_paths,2):

        # compute the jaccard distance for the current pair
        jaccard_index = jaccard(malware_attributes[malware1],malware_attributes[malware2])

        # if the jaccard distance is above the threshold add an edge
        if jaccard_index > args.threshold:
            print malware1,malware2,jaccard_index
            graph.add_edge(malware1,malware2,penwidth=1+(jaccard_index-args.threshold)*10)

    # write the graph to disk so we can visualize it
    write_dot(graph,args.output_dot_file)
